متد,کاربرد به فارسی
"map(Function<T, R>)",وقتی داده رسید، آن را به نوع دیگری تبدیل کن (مثلاً User را به DTO تبدیل کند).
"flatMap(Function<T, Mono<R>>)",داده را دریافت کن و یک Mono جدید برگردان (برای فراخوانی غیرهمزمان بعدی).
"flatMapMany(Function<T, Flux<R>>)",داده را دریافت کن و یک Flux از آن ایجاد کن (تبدیل یک به بسیاری).
filter(Predicate<T>),فقط عناصری را انتخاب کن که شرط مشخصی را داشته باشند.
"filterWhen(Function<T, Mono<Boolean>>)",شرط را بر اساس یک فراخوانی واکنش‌پذیر (مثل سرویس دیگر) تعیین کن.
doOnNext(Consumer<T>),وقتی هر آیتم جدیدی دریافت شد، یک عمل (مثل لاگ) را انجام بده.
doOnComplete(Runnable),وقتی جریان کاملاً تمام شد (بدون خطا)، این عمل را انجام بده.
doOnError(Consumer<Throwable>),اگر خطایی رخ داد، این عمل (مثل گزارش خطا) را انجام بده.
doOnSubscribe(Consumer<Subscription>),وقتی اشتراک‌گذاری (subscribe) شروع شد، این عمل را انجام بده.
doFinally(Consumer<SignalType>),در پایان، چه با موفقیت، چه با خطا، این عمل را انجام بده.
then(),بعد از تکمیل Mono، یک Mono<Void> برگردان (فقط ادامه دادن زنجیره).
thenReturn(T),بعد از تکمیل، یک مقدار ثابت را برگردان.
switchIfEmpty(Mono<T>),اگر خروجی خالی بود، به جای آن یک Mono دیگر را برگردان.
defaultIfEmpty(T),اگر خروجی خالی بود، این مقدار پیش‌فرض را برگردان.
onErrorReturn(T),اگر خطا رخ داد، به جای خطا، این مقدار را برگردان.
"onErrorResume(Function<Throwable, Mono<T>>)",اگر خطا رخ داد، یک Mono جایگزین (مثلاً مسیر پشتبنا) را برگردان.
retry(),در صورت خطا، دوباره تلاش کن (با تعداد یا شرط مشخص).
block(),به صورت مسدودکننده (غیرواکنش‌پذیر) منتظر بمان تا داده برسد. (فقط در تست/غیرتولید)
blockOptional(),مانند block() اما خروجی Optional است.
subscribe(),جریان را شروع کن و داده‌ها را مصرف کن (معمولاً در انتها).
collectList(),تمام آیتم‌های Flux را جمع‌آوری کن و در یک Mono<List<T>> برگردان.
collect(Collectors),آیتم‌های Flux را با یک Collector (مثل toList، toMap) جمع‌آوری کن.
next(),اولین یا تنها آیتم Flux را به صورت Mono برگردان.
single(),انتظار یک آیتم داشته باش و اگر بیشتر یا کمتر بود، خطا بده.
hasElement(),Mono<Boolean> برگردان که نشان می‌دهد آیا حداقل یک آیتم وجود دارد.
ignoreElements(),تمام آیتم‌ها را نادیده بگیر و فقط Mono<Void> بعد از تکمیل برگردان.
timeout(Duration),اگر داده ظرف مدت مشخصی نرسد، خطا بده یا مسیر جایگزین برو.
cache(),نتیجه را پس از دریافت کش کن تا اشتراک‌های بعدی سریع‌تر باشند.
log(),تمام رویدادهای جریان (اشتراک، دریافت داده، خطا، تکمیل) را لاگ کن.
delayElement(Duration),بین ارسال هر آیتم، تأخیر زمانی ایجاد کن.
startWith(T),قبل از ارسال داده‌های اصلی، این مقدار را ارسال کن.
concatWith(Flux<T>),پس از تکمیل جریان فعلی، جریان دیگری را به آن اضافه کن (به صورت پشت سر هم).
mergeWith(Flux<T>),این جریان را با جریان دیگری ادغام کن (همزمان).
zipWith(Flux<T>),"آیتم‌های این جریان را با آیتم‌های جریان دیگر ""زیپ"" کن (دو به دو)."
"reduce(BiFunction<T, T, T>)",تمام آیتم‌ها را با یک عملگر (مثل جمع) ترکیب کن و یک Mono برگردان.
"scan(BiFunction<T, T, T>)",هر مرحله از ترکیب را به عنوان خروجی بده (نسخه پویای reduce).
hasNext(),بررسی کن آیا آیتم بعدی وجود دارد (بیشتر در تست استفاده می‌شود).
all(Predicate<T>),آیا همه عناصر شرط را دارند؟ خروجی Mono<Boolean>.
any(Predicate<T>),آیا حداقل یک عنصر شرط را دارد؟ خروجی Mono<Boolean>.
count(),تعداد کل عناصر Flux را به صورت Mono<Long> برگردان.
elementAt(int),آیتم در موقعیت مشخصی را برگردان (به صورت Mono).
window(int),Flux را به چند Flux کوچک‌تر (با اندازه مشخص) تقسیم کن.
"groupBy(Function<T, K>)",جریان را بر اساس یک تابع به چند زیرجریان تقسیم کن.
skip(long),اولین N آیتم را نادیده بگیر.
take(long),فقط اولین N آیتم را بگیر.
limitRate(int),نرخ جریان داده را برای جلوگیری از فشار زیاد کنترل کن.
cast(Class<T>),نوع داده را به نوع دیگری تبدیل کن (با اطمینان از سازگاری).
of(T...),یک Mono یا Flux از مقادیر ثابت ایجاد کن.
empty(),یک Mono یا Flux خالی ایجاد کن (بدون داده).
just(T),یک Mono از یک مقدار ایجاد کن.
fromSupplier(Supplier<T>),Mono را از یک تابع تولیدکننده ایجاد کن.
defer(Supplier<Mono<T>>),ایجاد Mono را تا زمان subscribe به تعویق بینداز.
error(Throwable),یک Mono یا Flux که بلافاصله خطا می‌دهد، ایجاد کن.
when(Mono<Void>...),چند Mono<Void> را منتظر بمان و وقتی همه تموم شدند، ادامه بده.
zip(Mono<T>...),چند Mono را منتظر بمان و نتیجه ترکیب آنها را برگردان.
firstWithValue(Flux<T>...),اولین Flux که داده بدهد را انتخاب کن و بقیه را نادیده بگیر.
"switchMap(Function<T, Publisher<R>>)",برای هر آیتم، یک Publisher جدید بساز و فقط آخرین آن را نگه دار (برای لغو درخواست‌های قدیمی).
publishOn(Scheduler),تغییر Thread اجرای عملیات به یک Scheduler دیگر.
subscribeOn(Scheduler),Thread اولیه اجرا (subscribe) را مشخص کن.