1
00:00:00,000 --> 00:00:04,820
hallo und herzlich willkommen auf dem
youtube-kanal von programmieren -

3
00:00:04,830 --> 00:00:10,129
staaten punkt.de mein name ist hendrik
und der titel im hintergrund verrät

5
00:00:10,139 --> 00:00:14,720
schon in diesem video wird es um die
sogenannten primitiven datentypen gehen

7
00:00:14,730 --> 00:00:20,480
und wir sind bereits in video 3 des java
crash kursus ich möchte gar keine zeit

9
00:00:20,490 --> 00:00:25,130
verlieren schauen wir direkt mal an was
wir in diesem video lernen werden

11
00:00:25,140 --> 00:00:30,859
zunächst mal werden wir lernen warum
benötigt man datentypen wir werden also

13
00:00:30,869 --> 00:00:35,240
einfach mal diese frage beantworten
danach werde ich dir eine übersicht über

15
00:00:35,250 --> 00:00:39,889
die primitiven datentypen geben
also was es da alles für datentypen gibt

17
00:00:39,899 --> 00:00:42,319
was die verwehrte bereiche haben und so
weiter

19
00:00:42,329 --> 00:00:46,549
und am schluss werden wir uns die
primitiven datentypen dann auch noch in

21
00:00:46,559 --> 00:00:50,420
der praxis ansehen da werden wir dann
wieder in die entwicklungsumgebung gehen

23
00:00:50,430 --> 00:00:54,920
und ein bisschen programmieren gehen wir
direkt mal zum ersten punkt auf unserer

25
00:00:54,930 --> 00:00:57,799
agenda
und zwar zu den punkt warum benötigen

27
00:00:57,809 --> 00:01:02,450
wir datentypen im letzten video haben
wir gelernt dass für sie immer benötigen

29
00:01:02,460 --> 00:01:06,679
denn wenn wir bei der deklaration von
variablen sind dann müssen wir diese

31
00:01:06,689 --> 00:01:10,910
datentypen immer mit angeben und jetzt
ist einmal die frage wieso muss der

33
00:01:10,920 --> 00:01:14,870
computer überhaupt wissen über diesen
datentyp haben und diese frage ist

35
00:01:14,880 --> 00:01:19,820
eigentlich relativ schnell beantwortet
denn der computer muss immer ganz genau

37
00:01:19,830 --> 00:01:24,679
wissen mit welchem wert er ist gerade zu
tun hat und damit auch vernünftig

39
00:01:24,689 --> 00:01:29,420
arbeiten zu können das liegt jetzt daran
weil der computer je nach art des wertes

41
00:01:29,430 --> 00:01:33,440
intern unterschiedlich vorgeht
er macht beispielsweise einen ganz

43
00:01:33,450 --> 00:01:37,700
klaren unterschied zwischen ganz zahlen
und komma zahlen für uns menschen sind

45
00:01:37,710 --> 00:01:41,359
es einfach nur zahlen
es ist uns eigentlich egal ob sie zahlen

47
00:01:41,369 --> 00:01:46,160
sind oder ganz zahlen aber der computer
macht ihren klaren unterschied und das

49
00:01:46,170 --> 00:01:51,710
liegt wiederum daran dass der computer
intern beispielsweise ja mit ganz zahlen

51
00:01:51,720 --> 00:01:56,480
ganz anders rechnet als mit komma zahlen
bei der multiplikation von zwei zahlen

53
00:01:56,490 --> 00:02:00,200
wird dies besonders deutlich
intern wird für ganz zahlen ein ganz

55
00:02:00,210 --> 00:02:04,730
anderes verfahren verwendet als bei
comma zahlen komma zahlen sind nämlich

57
00:02:04,740 --> 00:02:08,389
für den computer wesentlich schwerer zu
berechnen und deshalb kommen da auch

59
00:02:08,399 --> 00:02:11,679
komplexere
zum verfahren zum einsatz und damit der

61
00:02:11,689 --> 00:02:16,209
computer jetzt immer weiß welches
verfahren anwenden muss gibt es eben die

63
00:02:16,219 --> 00:02:20,619
datentypen die ihm immer ganz genaue
auskunft darüber geben mit was für

65
00:02:20,629 --> 00:02:25,030
werten erst jetzt gerade zu tun hat
das war jetzt mal der hintergrund wieso

67
00:02:25,040 --> 00:02:29,559
datentypen überhaupt existieren müssen
jetzt werden wir uns aber mal einen

69
00:02:29,569 --> 00:02:33,039
überblick über die datentypen
verschaffen und zwar genauer gesagt über

71
00:02:33,049 --> 00:02:37,599
die sogenannten primitiven datentypen
von denen insgesamt acht stück

73
00:02:37,609 --> 00:02:40,330
existieren
hierfür habe ich jetzt mal eine tabelle

75
00:02:40,340 --> 00:02:45,190
für dich vorbereitet in der alle acht
primitiven datentypen aufgelistet sind

77
00:02:45,200 --> 00:02:51,069
jeder der datentypen hat eine grösse und
einen wertebereich die größe gibt

79
00:02:51,079 --> 00:02:56,379
auskunft darüber wie viel speicherplatz
dieser datentyp verwendet das bedeutet

81
00:02:56,389 --> 00:03:00,580
im prinzip um so mehr bit verwendet
werden desto größer können auch die

83
00:03:00,590 --> 00:03:03,339
zahlen seien die darin abgespeichert
werden

85
00:03:03,349 --> 00:03:07,509
und abhängig von der größe ergibt sich
dann eben der zugehörige wertebereich

87
00:03:07,519 --> 00:03:12,159
der hier am schluss in der tabelle auch
noch mit angegeben ist und dieser werte

89
00:03:12,169 --> 00:03:16,780
bereich gibt genau an welche
spezifischen werte von den einzelnen

91
00:03:16,790 --> 00:03:21,069
datentypen aufgenommen werden können und
diese tabelle gehen wir jetzt einfach

93
00:03:21,079 --> 00:03:25,240
mal schritt für schritt durch
wir beginnen mal mit dem ersten datentyp

95
00:03:25,250 --> 00:03:29,740
boullion der hat eine größe die
undefiniert ist und das liegt daran dass

97
00:03:29,750 --> 00:03:34,330
ist ein ganz besonderer datentyp ist der
ein wertebereich hat nämlich nur von

99
00:03:34,340 --> 00:03:38,770
true oder falls das heißt in diesem
datentyp speichert man entweder den wert

101
00:03:38,780 --> 00:03:43,479
oder den wertvollen moment kannst
wahrscheinlich noch nicht viel damit

103
00:03:43,489 --> 00:03:46,089
anfangen
aber wenn wir dann im weiteren verlauf

105
00:03:46,099 --> 00:03:50,770
des crash kursus auf beispielsweise auf
statements zu sprechen kommen dann wirst

107
00:03:50,780 --> 00:03:55,420
du verstehen wieso so ein datentyp
notwendig ist als nächstes sehen wir den

109
00:03:55,430 --> 00:04:00,250
datentyp charakter der datentyp
charakter hat eine größe von 16 bit und

111
00:04:00,260 --> 00:04:07,629
umfasst ein wert im bereich von 0 bis
plus 65 1535 dann kommt der datentyp byd

113
00:04:07,639 --> 00:04:14,199
mit einer größe von 8 bit und der
wertebereich geht von minus 128 bis +100

115
00:04:14,209 --> 00:04:20,050
27 darauf folgt der datentyp short der
hat eine größe von 16 byd ist also

117
00:04:20,060 --> 00:04:24,100
doppelt so groß wie der daten
und der jetzt schon einen wert im

119
00:04:24,110 --> 00:04:34,030
bereich von minus 32 1768 bis + 32 1767
als nächstes kommt der datentyp integer

121
00:04:34,040 --> 00:04:37,870
den haben wir schon mal verwendet
innerhalb dieses crash kursus der hat

123
00:04:37,880 --> 00:04:43,330
eine größe von 32 bit und der umfasst
einen wert im bereich von minus 2 hoch

125
00:04:43,340 --> 00:04:51,610
31 bis +2 hoch 31 1 und das sind schon
zahlen die sind im millionenbereich also

127
00:04:51,620 --> 00:04:54,610
der umfasst einen sehr großen
wertebereich da kann man eigentlich

129
00:04:54,620 --> 00:04:58,570
schon fast alles drin speichern
sollte dieser datentyp aber dann doch

131
00:04:58,580 --> 00:05:02,920
mal nicht ausreichen dann gibt es eben
noch den datentypen der hat eine größe

133
00:05:02,930 --> 00:05:07,630
von 64 bit ist also doppelt so groß wie
integer und der umfasst ein wert im

135
00:05:07,640 --> 00:05:15,550
bereich von minus 2 hoch 63 bis +2 hoch
63 - 1 das ist schon irre groß also da

137
00:05:15,560 --> 00:05:19,990
kriegt man eigentlich fast alles rein
und dann kommen noch die datentyp float

139
00:05:20,000 --> 00:05:24,670
und double float hat eine größe von 32
bit der umfasst einen wert im bereich

141
00:05:24,680 --> 00:05:30,100
von 1,402 usw
und dann steht hier so ein ehe dieses e

143
00:05:30,110 --> 00:05:41,320
steht für mal 10 hoch minus 45 bis 3,40
28 mal 10 hoch + 38 hier das sind jetzt

145
00:05:41,330 --> 00:05:45,630
hier so komische zahlen weil in dem
datentyp flut und im datentyp double

147
00:05:45,640 --> 00:05:50,110
speichert man fließkomma zahlen also
alle zahlen mit einem komma und hier

149
00:05:50,120 --> 00:05:54,610
geht es um die genauigkeit also auf
wieviel nachkommen bestellen ist dieser

151
00:05:54,620 --> 00:05:58,780
datentyp genau und der datentyp babbel
der als letztes jahr folgt hat eben eine

153
00:05:58,790 --> 00:06:03,940
größe von 64 bit dadurch ist dieser
wesentlich genauer als flut und das

155
00:06:03,950 --> 00:06:06,490
erkennt man jetzt an dieser zahl die
brauche ich jetzt hier nicht vorlesen

157
00:06:06,500 --> 00:06:15,720
4,94 irgendwas mal 10 hoch minus 3 124
also das ist schon irrsinnig genau bis

159
00:06:15,730 --> 00:06:20,410
1797 usw
mal 10 hoch 3 108

161
00:06:20,420 --> 00:06:24,460
diese ganzen datentypen hier die kann
man jetzt noch mal feiner kategorisieren

163
00:06:24,470 --> 00:06:27,520
ich habe es gerade schon ein bisschen
erwähnt gehabt einmal haben wir hier den

165
00:06:27,530 --> 00:06:31,510
daten titulieren das ist eben ein ganz
besonderer datentyp indem man nur

167
00:06:31,520 --> 00:06:34,579
wahrheit' werte
man kann also entweder true oder falls

169
00:06:34,589 --> 00:06:38,999
charakter ist ebenfalls ein besonderer
datentyp denn hier kann man auch

171
00:06:39,009 --> 00:06:43,199
einzelne buchstaben drin speichern oder
andere anderweitige zeichen aber halt

173
00:06:43,209 --> 00:06:47,999
immer nur eins und die nächsten für
datentypen sind ganz zahl datentypen

175
00:06:48,009 --> 00:06:51,959
also dazu gehört bei dazu gehört schon
dazu kritischer und long

177
00:06:51,969 --> 00:06:56,129
hier kann man eben nur ganz zahlen drin
speichern und abschließend float und

179
00:06:56,139 --> 00:06:59,989
dabei die gehören der kategorie
fließkomma zahlen an

181
00:06:59,999 --> 00:07:04,439
damit haben wir die datentypen jetzt in
der theorie durch genommen und jetzt

183
00:07:04,449 --> 00:07:07,079
wechseln wir wieder in die
entwicklungsumgebung und sehen uns das

185
00:07:07,089 --> 00:07:11,069
ganze abschließend noch in der praxis an
ich habe jetzt hier wieder das gleiche

187
00:07:11,079 --> 00:07:15,119
programm geöffnet wie wir es in den
vorherigen videos auch schon verwendet

189
00:07:15,129 --> 00:07:17,279
hatten
ich habe hier einfach alles aus der

191
00:07:17,289 --> 00:07:21,839
methode ausgelöscht und hier schreiben
wir jetzt erneut unseren neuen code rein

193
00:07:21,849 --> 00:07:25,919
und was wir jetzt mal machen ist wir
möchten jetzt mal die unterschiedlichen

195
00:07:25,929 --> 00:07:30,179
datentypen der uns mit hilfe dieser
variablen erstellen wie man eine

197
00:07:30,189 --> 00:07:34,049
variable deklariert das haben wir
bereits gelernt man schreibt den namen

199
00:07:34,059 --> 00:07:38,729
des datendiebs hin dann eine bezeichnung
für die variable und dann das semikolon

201
00:07:38,739 --> 00:07:43,799
oder man initialisiert diese direkt und
weiß diese also direkt einen wert zu das

203
00:07:43,809 --> 00:07:47,309
machen wir jetzt mal und zwar nehmen wir
jetzt mal den barden datentyp den wir

205
00:07:47,319 --> 00:07:51,869
gerade kennengelernt hatten und den
nennen wir es mal test diese variable

207
00:07:51,879 --> 00:07:58,649
und diese initialisieren wird direkt mit
einem wert und zwar mit 120 und dann

209
00:07:58,659 --> 00:08:02,579
geben wir das ganze mal über eine print
allen methode aus indem ich jetzt hier

211
00:08:02,589 --> 00:08:07,019
den variablen name wieder übergeben und
wenn wir das programm jetzt ausführen

213
00:08:07,029 --> 00:08:10,799
dann sehen wir dass auf der konsole 120
ausgegeben wird

215
00:08:10,809 --> 00:08:15,779
ich hatte es vorn in der tabelle gezeigt
dieser datentyp byd hat einen wert im

217
00:08:15,789 --> 00:08:22,229
bereich von also bis maximal plus 127
ich kann jetzt hier also 127

219
00:08:22,239 --> 00:08:27,899
hinschreiben das ganze problemlos
ausführen und die 127 wird ausgegeben

221
00:08:27,909 --> 00:08:31,819
sobald ich diesen wertebereich jetzt
aber überschreite indem ich zum beispiel

223
00:08:31,829 --> 00:08:37,439
128 1 gibt sehen wir dass die zahl roth
unter klingelt wird und hier links

225
00:08:37,449 --> 00:08:41,939
erscheint so eine glühbirne mit einem
kreuz und wenn wir da drauf gehen dann

227
00:08:41,949 --> 00:08:46,490
sehen wir schon wird uns angezeigt
teig mismatch can convert from internet

229
00:08:46,500 --> 00:08:50,210
so weit und das ist jetzt eine
fehlermeldung die uns jetzt schon sagt

231
00:08:50,220 --> 00:08:54,470
so wird das programm nicht funktionieren
das liegt jetzt eben daran dass der

233
00:08:54,480 --> 00:08:57,770
computer jetzt diesen wert weil er zu
groß für beide ist und da gar nicht

235
00:08:57,780 --> 00:09:02,870
reinpasst als integer auf fast und uns
hier gleich den hinweis gibt integer

237
00:09:02,880 --> 00:09:07,900
passt nicht in weit rein weil es eben zu
groß ist wenn wir das jetzt zum beispiel

239
00:09:07,910 --> 00:09:13,100
in short um ändern würden einen datentyp
größer würde das ganze funktionieren bei

241
00:09:13,110 --> 00:09:17,450
inter und long natürlich genauso weil
die ein noch größeres fassungsvermögen

243
00:09:17,460 --> 00:09:25,310
haben aufgrund des größeren werte
bereichs und die wie gesagt solche

245
00:09:25,320 --> 00:09:29,210
fehlermeldungen die entwicklungsumgebung
unterstützt uns hier

247
00:09:29,220 --> 00:09:32,960
dann sehen wir das sofort du musst jetzt
einfach mal ein bisschen selbst

249
00:09:32,970 --> 00:09:36,530
herumprobieren mit diesen ganzen
datentypen damit du jetzt auch selbst

251
00:09:36,540 --> 00:09:40,130
wirklich ein gefühl dafür bekommst ich
kann dir jetzt hier viel zeigen aber

253
00:09:40,140 --> 00:09:43,250
wenn du es nicht selbst ausprobiert dann
wirst du dieses gefühl einfach nicht

255
00:09:43,260 --> 00:09:45,560
kriegen
deswegen setzt sich einfach mal mit der

257
00:09:45,570 --> 00:09:49,370
tabelle die du im letzten video gesehen
hast hin und probierte ein bisschen

259
00:09:49,380 --> 00:09:53,450
rumprobieren verschiedene werte aus dann
kriegst du ich relativ schnell ein

261
00:09:53,460 --> 00:09:57,770
gefühl dafür und dann kannst du diese
acht primitiven datentypen auch ratzfatz

263
00:09:57,780 --> 00:10:01,790
auswendig was wir uns jetzt vielleicht
noch mal angucken ist der datentyp

265
00:10:01,800 --> 00:10:06,710
boullion weil das scheint jedoch ein
spezieller war datentyp zu sein und

267
00:10:06,720 --> 00:10:11,390
dieser datentyp julian der hat hier nur
ein wertebereich naja von true oder

269
00:10:11,400 --> 00:10:15,410
falls wir können sich also true
hinschreiben wir sehen die fehlermeldung

271
00:10:15,420 --> 00:10:18,920
ist weg und wenn wir das programm
ausführen wird schuhe ausgegeben auf der

273
00:10:18,930 --> 00:10:23,390
konsole und wir können genau so auch den
anderen wert hinschreiben denen diese

275
00:10:23,400 --> 00:10:28,160
datentyp fassen kann nämlich holz und
auch wenn wir das aufgeben wird volz auf

277
00:10:28,170 --> 00:10:31,970
der konsole ausgegeben
in dem kontext hier macht es jetzt

279
00:10:31,980 --> 00:10:37,220
gerade natürlich relativ wenig sinn
aber wenn wir in dieser youtube serie

281
00:10:37,230 --> 00:10:42,620
hier voranschreiten und zudem statements
gelangen dann wirst du sehen dass dieser

283
00:10:42,630 --> 00:10:46,970
daten titulieren sehr wohl eine
existenzberechtigung hat und was ich dir

285
00:10:46,980 --> 00:10:50,180
jetzt vielleicht auch noch zeigen möchte
sind die comma zahlen dann nehmen wir

287
00:10:50,190 --> 00:10:55,370
den datentyp da will jetzt mal her
den nimmt man da in der regel und hier

289
00:10:55,380 --> 00:10:58,940
kann man jetzt eben komma zahlen drin
speichern und in der programmierung ist

291
00:10:58,950 --> 00:11:02,780
ganz wichtig zu wissen dass man hier
jetzt aufpasst dass man kein komma macht

293
00:11:02,790 --> 00:11:08,120
sondern als komma sozusagen den punkt
verwendet man schreibt also nicht 2,3

295
00:11:08,130 --> 00:11:14,210
sondern man schreibt 2.3 wenn man 2,3 ab
speichern möchte das liegt einfach daran

297
00:11:14,220 --> 00:11:17,750
dass sich hier in der programmierung
alles da am englischsprachigen raum

299
00:11:17,760 --> 00:11:22,460
orientiert und da ist eben der punkt
dass komma bezahlen und nicht wie in

301
00:11:22,470 --> 00:11:26,480
deutschland das komma
das musst du einfach wissen und jetzt

303
00:11:26,490 --> 00:11:31,730
kann man das ganze einfach mal ausgeben
lassen und dann sehen wir die 2,3 wird

305
00:11:31,740 --> 00:11:35,420
ausgegeben und genauso kann es jetzt mal
gucken wenn du hier ganz viele

307
00:11:35,430 --> 00:11:42,850
verschiedene zahlen daran hängt zum
beispiel 2,1 2 3 4 5 6 7 8 9

309
00:11:42,860 --> 00:11:48,650
so dass sie mit cola natürlich ans ende
und wenn du das ganze jetzt mal aus

311
00:11:48,660 --> 00:11:54,170
fürst dann kannst du überprüfen was wird
denn jetzt noch ausgegeben wir sehen

313
00:11:54,180 --> 00:11:57,860
alle zahlen wird ausgegeben die
genauigkeit erreicht also aus wenn wir

315
00:11:57,870 --> 00:12:03,920
hier nochmal 1 2 3 4 5 6 7 8 9 anfügen
und das ganze jetzt noch mal

317
00:12:03,930 --> 00:12:07,850
ausprobieren dann sehen wir diese ganze
zahl kann jetzt schon vom wertebereich

319
00:12:07,860 --> 00:12:11,480
nicht mehr gefasst werden dass die
genauigkeit dann doch zu gering

321
00:12:11,490 --> 00:12:16,190
und ja da wird dann hier hinten ab dem
sechsten wert gerundeten der wird eben

323
00:12:16,200 --> 00:12:24,560
auf 7 gerundet weil hier der wert größer
als 5 ist bzw 5 oder größer als 5 ist es

325
00:12:24,570 --> 00:12:28,340
sind die normalen rundes regeln wie man
sie aus der schule schon kennt und das

327
00:12:28,350 --> 00:12:31,580
war jetzt eigentlich schon alles was ich
dir in diesem video zeigen wollte wie

329
00:12:31,590 --> 00:12:34,910
gesagt probiert selbst damit rum damit
ein gefühl für diese datentypen

331
00:12:34,920 --> 00:12:39,200
entwickelt und dann bedanke ich mich für
deine aufmerksamkeit falls ihr das video

333
00:12:39,210 --> 00:12:42,830
gefallen hat du ein mehrwert daraus
ziehen konnte ist dann würden wir uns

335
00:12:42,840 --> 00:12:46,370
wahnsinnig darüber freuen wenn du uns
einfach kurzen daumen nach oben gibt in

337
00:12:46,380 --> 00:12:50,240
denen da unten auf diesen daumen nach
oben klickst oder falls du den youtube

339
00:12:50,250 --> 00:12:54,410
kanal noch nicht abonniert haben sollte
ist uns ein abo da lässt indem du

341
00:12:54,420 --> 00:12:58,040
einfach unten auf den button jetzt
abonnieren klickst du hast du immer die

343
00:12:58,050 --> 00:13:02,390
neuesten videos in deiner inbox und
unser kanal wächst das also eine win win

345
00:13:02,400 --> 00:13:05,500
situation
ich bedanke mich für deine aufmerksam

347
00:13:05,510 --> 00:13:11,200
noch einmal und dann sehen wir uns im
nächsten video wieder bis dahin

348
00:13:07,280 --> 00:13:11,200
nächsten video wieder bis dahin

