Du konntest schon erste Kenntnisse in der Programmiersprache Java sammeln und möchtest jetzt deinen ersten Job als Entwickler angehen. Da müssen wir genau richtig dahin. Hast du die Grundlagen der Spring- und Deck-Entwicklung und dabei nicht nur die praktischen, sondern auch theoretischen Aspekte, damit du in einem Interview mit potenziellen Arbeitgebern oder Kunden wirklich überzeugen kannst. Damit viel Spaß beim Video. Ich würde eine kurze Einleitung zur Spring auch den weiteren Verlauf des Kurses geben. Würde das Video anguckst, weißt dass bestimmt schon, aber es Spring ist ein Web-Application-Framework, d.h. wir benutzen das Spring als Entwickler, umzuhören zu einem Werkzeugkasten zu bekommen, der uns das Bauen von Web-Applikationen vereinfacht. Das heißt, viele Sachen sind für uns schon vorbereitet, damit wir da nun auch unsere Logik ergänzen müssen. Unsere Logik ist neben dem Fall, meine ich natürlich die Business-Logik, also was unsere Anwendung versucht für ein Problem zu lösen. Das Spring-Framework an sich ist schon ein bisschen älter. Das Ganze ist dann auch entsprechend sehr sehr groß geworden. Spring an sich hat ein sehr vielseitiges Ökosystem von ganz vielen verschiedenen Modulen, die man alle in Spring benutzen kann. Was Spring hat, ist der Ansatz "Convention over Configuration". D.h. früher, als man Adresse des Spring-Anwendung aussetzen musste, da hat man sich viel Zeit damit verbracht, verschiedene Module vorher nochmal zu konfigurieren, bevor man eigentlich zum Programmieren der Anwendung kam. Und das Problem versucht Spring so ein bisschen zu lösen, indem es uns für alle Module noch meine Vorkonfiguration gibt. Es heißt, viele Sachen werden für uns schon bereitgestellt, oder es wird etwas machen können, und dadurch wird eine sogenannte Boilerplate-Code, also Code, der immer wieder wiederholt wird, aber sich nicht wirklich von Anwendungen zur Anwendungen groß unterscheidet, halt vermieden. Das ist für uns sehr sehr gut als Entwickler. Der Grund, warum du Spring lernen solltest, ist, wenn du Java-Entwickler bist. Und Java ist in Deutschland vor allem eines der meistgenutzten Sprachen unter professionellen Entwicklern. Und da gibt es auch einige Jobs für, also ist auf jeden Fall eine gute Wahl. Dann ist das nicht gut, Wahrscheinlichkeit groß, dass neue Projekte, die aufgesetzt werden, mit Spring Boot aufgesetzt werden. Es ist einfach das etablierteste Framework heutzutage, ist ein bisschen der Standard. Und ja, es ist auch zu Recht, glaube ich, meiner Meinung nach. Der Kurs an sich ist sehr fokussiert auf Spring. Gut, ich werde meine verschiedenen Teile des Kurses, wo man vielleicht anderes Hintergrundwissen benötigt, das explizit auch mal sagen, aber ich möchte nicht die Leute mit dem Hintergrundwissen davon abhalten, Spring zu deren und dann gelang wahr zu sein, weil zu viele andere Themen erklärt werden. Entsprechend würde ich dich bitten, andere Kenntnisse außerhalb des Großen mit dem anderen Tutorial, was ich besser damit beschäftigt zu lernen, und alle Diskurs, alle Teil des Kurses entsprechend auch alleinstehende kannst zwischen den Teil des Kurses wechseln. Es werden vorher nochmal alle Vorkenntnisse nötig sind aufgelistet, damit du auch wirklich nichts verpasst. Im ersten Teil des Kurses werde ich euch dem Spanish Leiser zeigen. Wir unser Grundprojekt erzeugen werden. Hierfür sind keine Voraussetzung gegeben, also ihr solltet euch mit Java auskennen, aber jeder kann dieses Tutorial eigentlich befolgen. Wir werden jetzt einmal den Spring die Schleuser öffnen. Dafür gehen wir auch Startpunkt. Haben wir eine einfache Web-Oberfläche, wo wir unser Projekt definieren können. Dafür werde ich jetzt erstmal als Package Manager, also als Verwaltungsprogramm für unsere Dependencies, die Bibliotheken, die für unseren Java oder unseres Ringguth Application nutzen. Auf Nebensätzen also ist hier schon vorher stellt die Sprache auf Java. Die Spring-Gut-Version auf 2.5 Punkt 3. Den Namen des Projekts werde ich jetzt einfach mal auf "Beispielprojekt" setzen. Klar als Packaging die Version von Java auf die 8. Und ich werde jetzt eine die Pansy, also eine Bibliothek, hinzufügen, und es ist die Spring Web. Es gibt noch viele weitere, wenn man sich das alles mal durchlesen will und da was uns weiteres hinzufügen will, kann man das gerne machen, aber für dieses Tutorial werden jetzt einfach mal nur Spring Web auswählen. Wenn ich auf das ganze jetzt mal generieren lassen und Safe anklicken, habe ich hier mal einen Download. Ich werde das ganze ist einfach mal extrahieren. Worauf Extrakt klicken. Tutorial aussuchen. Das hat funktioniert. Dann werde ich ihn intelligent das Projekt öfter DJ ist mein die integrierte Development Environment, wo ich meinen Java-Code schreiben werde. Würde ich auch gerne was anderes benutzen, nicht für mich persönlich ist Jain der beste. Dann würde ich hier auf Project gehen. Das ist jetzt nur der Ordner bei mir in bei mir der Vaart. Und unser Beispielprojekt mal öffnen. Wir sehen hier, es ist schon von TG als Nebenprojekt erkannt wurden. Da wird jetzt alle unsere die Entensys, also Bibliotheken für uns installieren. Wir können jetzt einmal in die POM.xml reinschauen. Comics E-Mail bei mehreren Projekten definiert die Bibliotheken, die wir in unserem Projekt nutzen. Das wäre dann einmal das Spring-Startup, das Test-Framework für Spring auch den Menschen planen. Und wir uns unser Projekt einmal anschauen, dann werden wir sehen, dass da noch nicht viel drin ist. Wir haben so ein Beispiel-Test, der aber auch wer ist eigentlich. Wir haben eine Menge Klasse, die mit Splitter notiert ist. Und beim der Resource-Ordner also dieses Application-Properties-Datei ist jetzt auch leer. Wir werden es immer einfach trotzdem nochmal unser Anwendungen die Stadt um zu gucken, was uns Spring da einfach mal gibt. Jetzt hat sich eine Console geöffnet. Wir sehen, dass der Tomcat-Web-Server ist ein Application-Server, auf dem Spring jetzt laufen wird auf dem Port 8080 auf unserem Computer gesteuert hatten. Ich werde jetzt einfach mal drauf zugreifen. Dem ich auf den Localhost 8080 navigiere und bekomme jetzt von einem Web-Server 1 404 Not Found. Das heißt, wir haben hier einen invaliden Fahrrad oder ein Fahrrad, worauf der Web-Server nicht weiß, was er antworten soll. Das ist gegeben, da wir jetzt bin ich gesagt haben, wie wir auf verschiedene Anfragen reagieren möchten. Aber immerhin haben wir schon mal eine funktionierende Anwendung. In diesem Teil des Kurses werden wir lernen, wie HTTP-Anfragen in Spring gut verarbeitet werden. Also ist es schon dafür, dass du ungefähr weißt, wie HTTP funktioniert, und das Spring-Schleuser-Projekt vielleicht schon mal aufgesetzt hast, damit du die Tore hier auch folgen kannst. Also mit Spring-Booster-Web sowie in den vorigen Teil des Kurses. Wir sind jetzt wieder einen Teil der bisher ein einfaches Spring-Starter-Web-Projekt. Also sind hier noch keine Sachen hinzugefügt wurden, einfach nur quasi Tier da, wo wir schon im letzten Torlauf gehört haben. Und wir werden jetzt einen einfachen Controller erzeugen. Und ich würde jetzt ja einmal die Klasse Hello-World-Controller erzeugen und die Annotation RestController hier hinzufügen. Was das jetzt macht, ist es gibt dieser Klasse die Möglichkeit, verschiedene Fahrer in der URL zu erkennen und darauf Responses zu geben, also Daten zurück zu senden. Aber dafür müssen wir den Controller erstmal sagen, auf welche Pfade er überhaupt reagieren soll. Das werden wir jetzt einmal ein Gate-Mapping benutzen. Dafür mache ich erstmal eine Location, die hier auch heißt nur Kipping. Und werde hier den Pfad "hallo" angehen. Und ich werde ihnen noch eine Methode, das muss man immer dazu gehen bringen, wenn man so ein Cache-Mapping erzeugt. Und das ist quasi die Methode, die dann aufgerufen wird, wenn dieser Fahrer also dann bei uns seinen Localhost 8080 mit diesem Pfad "hallo" aufgerufen wird. Das ist in diesem Fall würde ich sagen "Hello World". Und gebe dann zurück "Hallo Welt". Genau, jetzt wird das ganze einmal testen werden ja in Form eines Spring-Anwendung starten. Jetzt in meinem Browser, ich werde jetzt hier einmal auf Localhost 8080 gehen. Und wie ihr seht, kriegt man auf den 404, also Not Found Fehler. Das ist klar, weil wir haben ja noch gar kein Meeting auf diesen Lehrern Fatih auf unseren Home Vaart ist, dass er üblicherweise. Jetzt will ich einfach mal "hallo" eingeben. Und wie sieht, haben wir jetzt hier "Hello World" zurückbekommen. Und das ist so ein bisschen die Grundlage, was der RestController macht. Es nochmal ein bisschen hinter die Kulissen gucken, um euch zu erklären, was da eigentlich bei unseren Break West gerade passiert ist. Wenn wir unseren Gatwick-Kurs des Browsers machen an den Pfad "hallo", wird erstmal ein Gatwick-West an der Application-Server geschickt, dass unser Traum-Kat fast erinnert der Sprintstar-Web kommt mit dem Tomcat, der so konfiguriert wird, dass ja auf den Port 8080 hört. Wenn wir unsere Spring-Anwendung starten, dann wird der Rest weitergeleitet an den Tomcat-Service-Container, bei dem dann möglicherweise mehrere Anwendungen laufen oder mehrere Services, die für die verschiedenen Java-Anwendungen Requests hingegen nehmen und bearbeiten. In diesem Fall haben wir dann nur einen Service, und zwar den Sprint des Bechers Service, die das Spring-Anwendung hat diesen Dispatcher-Service. Und was dieser Service dann macht, ist er nimmt die Anfrage entgegen, guckt, ob er irgendwelche Controller sind, z.B. Hallo-Controller, der diesem Request bearbeiten kann. Das heißt dann muss natürlich einmal die mit der Methoden-Typ übereinstimmen. Und der Fahrer in diesem Fall ist ja beides auf den Hallo-Controller zurückzuführen. Wenn wir zum Beispiel einen Pfad angeben, den es nicht gibt, dann wird der Tomcat bzw. Spring 1 404 zu geben, weil wir können den Rekord nicht richtig bearbeiten. Wir wissen nicht, welchen Controller wie das zuweisen sollen oder welchen Kurve dann laufen lassen müssen. Aber hier wissen und wissen wie es ja und unser Controller erstellt dann quasi unsere Response, die wird dann weitergeleitet und letztendlich zurück an den User geleitet. Noch einmal uns zu erklären, weil es schon etwas abstrakt ist. Als Entwickler hat man nicht so oft damit zu tun. Und zwar im Prinzip des Java-Servlet. Java-Servlet sind Klassen, ist ein Standard zum Annehmen und Abarbeiten von HTTP-Request in Java. Wir brauchen um ein Java-Services laufen zu lassen eine Service-Engine, ein Container, das normalerweise ein Application-Server. Da gibt es mehrere, zum Beispiel James oder auch Tomcat, den wir jetzt gerade benutzen. Und die Spring-Anwendungen benutzen generell den Dispatcher-Service. Das ist sozusagen das, das ist der Default-Service für jedes Spring-Wendung. Und der Service zuständig, dass unsere Bus-Controller zum Beispiel die verschiedenen Anfragen und so weiter bearbeiten können. Wir werden uns aber mit der Theorie der dem Thema Dependency Injection beschäftigen. Die Pens-Injection ist einer der größten Features bei Spring. Eine der wichtigsten Sachen entsprechend finde ich es wichtig, dass wir das auch wirklich verstehen, verstehen, warum das gemacht wird. Und natürlich wird es auch öfter mal in Interviews gefragt, dass man erklärt, was eigentlich dahinter passiert, warum man das macht etc. Eine Dependence sie also besitzt einfach nur eine Abhängigkeit. Und wenn wir Software entwickeln, möchten wir als Entwickler Abhängigkeiten unserem Coach soweit es geht vermeiden. Ich erkläre ich mal warum an einem echten Beispiel für den deutschsprachigen Raum. Habe ich natürlich eine Autofabrik hier als Beispiel ausgewählt. Da sehen wir in dieser Fabrik, wie ein Auto zusammengesetzt wird. Und dafür haben wir ein Grundgerüst für unser Auto. An diesem Grundgerüst werden wir gerade mehrere Komponente einbauen. Aber dabei ist halt wichtig, dass wir nicht zu abhängig von den anderen Fabriken werden. Was heißt das genau? Wenn ich mein Auto bauen möchte, ich zum Beispiel nicht mein Auto so bauen oder ein Gerüst so bauen, dass ich dann nur eine Art von Reifen rein tun kann. Weil wenn zum Beispiel mein Reifen-Lieferant die Preise zu sehr erhöht oder pleite geht, dann habe ich auch das Problem, dass ich keine Reifen mehr bekomme und meine Fabrik steht still. Und wenig im Kopf haben wir falls du dich an die Grundlagen der objektorientierten Programmierung. Mariners Interfaces als Programmierer, mit denen wir eine Abstraktion unserer Klassen erzeugen können. Das heißt, wir sagen zum Beispiel, ich habe jetzt hier eine Motor-Fabrik und würde dann vielleicht eine Instanz oder eine Implementation dieses in diesem Fall einem Interface nennt sich das in Java erzeugen. Und dem Verhalten sind aber die des Motor-Factory oder die Bet-Motor-Factory. Was aber nur zeigen sollen, das sind zwei unterschiedliche Versionen einer Moto-Factory. Und kann dann jemand unten sieht beliebig austauschen, welche Fabrik ich da in mein Objekt ist eine Variable einfüge. Was das ganze entkoppelt in dem Sinne, dass ich nicht an eine gewisse Fabrik hier meine Variable gebunden bin, kann die austauschen mit dem New-Key-Word unterschiedliche Fabriken hier zu weisen. Jetzt wird sich aber zeigen, dass ist da immer noch eine Abhängigkeit erzeugt wird. Wird und zwar in einem Beispiel, was sie jetzt wieder an der Autofabrik mache, diesmal aber im Kot. Und zwar habe ich hier eine Autofabrik, die das Interface Motor-Factory als Variable hier in unserer Klasse hat. Das heißt, wir haben hier eine generische Motorenfabrik. In dem Fall habe ich mich hier für die beste Fabrik für entschieden, Mode beste Motor-Factory. Und das Geschäft läuft gut, wir machen ordentlich Umsatz mit unserer Fabrik. Und entsprechend schießen dann bald viele weitere Fabriken in unserer Cobains hinzu. Und die wird sind alle die besten oder Factory, das heißt überall benutzen wir dieses New-Key-Word. Wir haben nach wie vor die das Model-Factory-Interfaces, heißt wir haben soweit entkoppelt, dass wir jede Motor-Factory diesem dieser Variable hinzufügen können. Aber da die besser oder Factory einfach die besten Motor produziert, benutzen wir das ganze einfach überall und benutzten die beiden You Beth Moore the Factory. Da passiert was ganz traurig ist. Und zwar unsere besten Lotterie-Factory explodiert. Und wir können unsere Produktion nicht weiterleiten, also alle unsere Fabriken stehen jetzt still. Wir bekommen keine Motoren mehr. Was müsst ihr mal reden, was ihr in unserem Chor ein Problem erzeugt hat. Und zwar unser Anforderung haben sich geändert. Wir wollen jetzt eine andere Fabrik da haben vor unserem Motor. Weil wir durch das New-Key-Word gesagt haben, dass wir überall diesem Best-Motor-Factory einbauen möchten, haben wir in unserem Code eine Kopplung erzeugt. Wir sind an diese Best-Model-Factory gekoppelt, obwohl wir Interface benutzt haben. Dann hat er noch sehr viele Instanzen erzeugt von unserer besten Motto-Factory. Was auch eventuell ohne dich ist, wenn zum Beispiel unsere besten oder Factory in meinem Motor erzeugt, dann kann es sein, dass vielleicht auch eine Fabrik genügt. Hier kommt dann die Pension Jackson ins Spiel. Und zwar falls ihr meine lenken größere Java-Entwickler Java-Programm geschrieben habt, wisst ihr das vielleicht, dass man vielleicht bei dem ein Klasse anfängt, man erstellt ein paar Klassen. Und in den Klassen nehmen immer mehr Klassen eingebaut. Und vielleicht reichen die Klassen sich gegenseitig ein paar Klassen weiter runter. Und hatte am Ende so eine Baumstruktur hier wie auf der linken Seite ihren diesem Diagramm gezeigt wird. Und auch das zeigt, wie ohne die Pens-Injection der Code halt immer komplexer wird. Mit die Pension Jackson haben wir dann andere Ansatz. Und zwar haben wir eine Klasse hier haben sie das Ding Pansy in Sektor genannt. Wir werden vielleicht gucken, wie das Bring heißt. Und diese Penalty im Sektor ist dazu da, unsere Abhängigkeiten an die verschiedenen Klassen weiterzugeben. Ist dass wir hier in unserem kommt uns nicht mehr darum kümmern müssen, wie wir das ganze hier zum Beispiel in diese Baumstruktur unter gereicht wird. Der Defense-Sector macht das ganze für uns automatisch. Tatsächlich ist die jetzt unser Beispiel in Spring funktionieren würde, wenn wir jetzt Bring benutzt hätten statt das ist ihr vorgemacht haben. Und zwar als Spring einen sogenannten Application-Kontext. Und diese Application-Kontext erzeugt dann die Instanzen unserer Klassen. Zum Beispiel in diesem Fall unserer Best-Motor-Factory. Der wird doch einmal erzeugt. Und diese Application-Kontext wird dann da, wo unsere Mode-Factories angegeben werden, eine passende Instanz an der Cluster in diesem Fall dem Motto-Factory einfach einfügen für uns automatisch. Das passiert, weil wir hier das Add-On the Way to Notation hinzugefügt haben. Spring weiß, dass wir eine Klasse haben in unserem Application-Kontext. Nimmt man dann auch alle Bienen und fügt es dann für uns ein. Wir müssen nicht irgendwie eine mit New irgendwas deklarieren oder uns selbst darum kümmern, wie diese Klasse erzeugt wird. Das heißt, wenn die besten oder Factory jetzt wegfällt wie in unserem Beispiel, können wir da einfach in unseren Application-Kontext zum Beispiel neue Factory einfach einbauen und automatisch mit Spring wieder genau wie vorher die neue Factory-Implementation hier einfach einfügen unsere anderen Klassen. Das ganze nennt sich dann in Virgen of Control, weil wir Spring diese Aufgabe oder die Kontrolle über die Allokation unsere Klassen-Instanzen abgeben. Darüber hinaus sollte die Pens Jackson auch viele weitere Vorteile. Natürlich einmal wie wir schon gesehen haben, wir haben weniger Abhängigkeiten. Wir benutzen das New-Key-Word nicht mehr. Wir haben generell weniger Code. Und was man später noch mal in der Praxis anschauen werden ist, wir können dadurch auch unsere Programm leichte testen. Wir können zum Beispiel Dummy-Klassen, sogenannte Mox, durch dieses die Penn-Station in unser Programm einfügen, wodurch wir dann vordefinierte Rückgaben deklarieren können. Das macht testen sehr einfach. Automatische Tests schreiben. Wir sind wieder ein Intel ging ich. Ich möchte euch jetzt einmal zeigen, wie Fancy-Injection wirklich funktioniert. Eben Spring, ich habe jetzt hier einfach nur ein Spring-Messer-Projekt mit auch wieder nur den Staat arbeiten. Das erste, was ich machen will, ist ich möchte einer von den Bands hier für den Spring-Kontext deklarieren. Falls solche NetBeans sind einfach nur Instanzen von unseren deklarierten Klassen, die Spring für uns dann die Pens sie entdeckten kann, also in andere Klassen einfügen kann. Damit wir das ganze so ein bisschen dynamisch machen können, müssen wir einige Regeln in Spring befolgen. Als erstes werde ich da einmal ein Interface um eine Klasse deklarieren. Und dann werde ich eine Implementierung des besagten Interfaces deklariert. Jetzt kommt der entscheidende Teil. Und zwar ganz einfach nur mit Komponenten notieren. Es muss der Spring and Component seien hier. Und was ich jetzt Spring gesagt habe ist, beim Starten der Anwendung liegt mir einfach eine generische Instanz, also das ganze wird dann mit dem TV-Constructor aufgerufen mit dem New-Key-Word irgendwo im Hintergrund, wo wir es nicht sehen. Und in diesen Application-Kontext gelegt von dem wir vorher gesprochen haben. Und diesen Application-Kontext werde ich mir um das ganze euch mal zu zeigen jetzt in eine Variable stecken. Und mir diese Instanz der SC Hella-Service und mal extrahieren, dass ich hier einen Saison-Fing-Service deklarieren. Und mit dem Application-Kontexten-Methode geht Wien aufrufen. Und sich so viel Glas aus den Eingaben Wert geben. Und das letztlich doch etwas machen, was auch jetzt nur für Tutorials gedacht ist. Und zwar mit dem Sales-und-Service-System auf benutzen. Das will ich die ganze Anwendung einmal laufen lassen. Macht hat man irgendwelche Dependency drehen. Und wir sehen haben wir unten "Hello World" als Ausgabe. So gesehen ist in diesem Application-Kontext irgendwie eine neue Instanz gelangt von unserer Klasse. Das ist alles so ein bisschen wie Magie von Spring, die uns da schon einiges abnimmt. Jetzt kann es aber natürlich auch sein, dass wir vielleicht gar nicht irgendwie dass wir gar nicht wollen, dass das Bring einfach so einen Default-Instanz unserer Klasse erzeugt, ohne dass sie irgendetwas konfigurieren. Und dafür können wir tatsächlich auch in Spring etwas genauer werden, dass wirklich einmal zeigen, wie das ganze funktioniert. Und zwar das ist ja einmal aus kopieren aus kommentieren. Mit dem Service an also sage ich mal den "Say-Something" of Service der Hit auf Wiedersehn "Say-Something"-Service mit dem Unterschied, dass wir jetzt hier eine String "What to Say". Und hier gebe ich jetzt als war das nun ernst Ring an. Und wie sieht welche das ganze jetzt nicht mit Component an notieren. Der Grund dafür ist, dass ich mir jetzt hier noch eine weitere Klasse erzeugen werde dich nennen werde "Something-Konfiguration". Und der gebe ich jetzt hier die Annotation Konfiguration. Was diese Kontinuität-Konfiguration-Annotation macht ist, sie sagt Spring das am Anfang, wenn das Programm startet, diese Klasse dafür zuständig ist, Dienst zu erzeugen und die sind Application-Kontext zu legen, damit er sie damit diese das machen kann. Müssen wir innerhalb Methoden an geben, den wir auch wieder mit Edwin alttieren. Hier jetzt mache ich den "Say-Something"-konfigurierbar-Service. Und ja, wir sehen, was Bring gemacht hat, ist es hat als erstes diese Methode aufgerufen im Hintergrund, wo sie eine Bienen erwartet bei den Instanz. Und wir haben wiederum einmal den generischen "Say-Something"-konfigurierte Server es hier instanziert. Das heißt, wenn ich jetzt zum Beispiel at Component hätte, dann wäre das so, als hätte ich das einfach dann direkt return. Aber ich habe hier vorher noch was mit meiner Instanz und mein Abi gemacht, so dass wir hier als Ausgabe das bekommen, was ich hier mit dem "Said that brought you say" gesetzt habe. Ich hoffe, dass alles Sinn gemacht wie eben schon gesehen hat. Habe ich hier musste ich hier dafür noch mal damit ich aus meinem Kontext meine Saison-Service bekommen habe. Das ganze hier aus kommentieren, das könnt ihr nochmal zeigen. Das ganze liegt daran, dass Spring immer wissen muss, welche Klasse ist gerade installieren kann. Das heißt gerade haben wir zwei Bands, die beide von den Saints anfing Service implementieren, also unser Sex haben wir komplett Service unseres Service. Aber es Spring nicht wie es dazwischen unterscheiden kann. Und da gibt es auch zum Beispiel ein relativ einfache Methode. Es gibt natürlich sehr viele, so wie immer ins Bringen gibt es mehrere Wege, etwas zu machen. Ein einfacher Weg ist einfach, indem man hier eine als der eine der Dienst als Emery markiert. Und dadurch hat diese Bienen Vorrang, wenn man einfach nur aus dem und aus dem Kontext sagt, ich möchte ich in der Bienen bekommen. Und entsprechend werden wir hier jetzt gleich unten Hannover, tschuldigung, gut weise integriert. Ich möchte jetzt noch mal was anderes machen. Ich möchte mich jetzt nicht mehr mit dem mit dem Konto hier unten mit auseinandersetzen, sondern euch nochmal das Add-On the Wire zeigen, was sie auch wirklich der größte Vorteil von Le Pens-Injection ist, dass wir mit Spring einfach unsere Beans in irgendwelche Klassen weisen können. Der kritischen Kontext kann nur Wiens in andere Wiens stecken, sonst weiß ja nicht von diesen Dienst nicht wieder irgendwas rein stecken soll. Das gute ist, dass viele Klassen von Spring automatisch Wiens sind, auch wenn da nicht irgendwie Component oder so was dran steht. Zum Beispiel wäre da auch unsere Rest-Controller, die wir schon in vorherigen Teil des Kurses kennengelernt haben. Was kannst du dich noch immer zeigen, wie das ganze halt auch zusammen funktioniert, damit ihr vielleicht auch eine Idee bekommt, wie das in der Praxis benutzt wird. Sich immer dem Rest-Controller hier deklariert. Komm nutze ich das auf deklariert. Das ist ein "Say-Something"-Service ist. Das ganze einfach wie noch wie gewohnt in eine Variable bei Java und gibt jetzt hier was zurück. Wenn ich jetzt mein Programm noch mal starte, sind wir hier das wir von unserem Rest des Controller "Goodbye Brücke" zurückbekommen auf unsere Anfrage. Und hier unten die Konsolen-Ausgabe wieder verschwunden ist. Jetzt kann es aber sein, dass ich zum Beispiel jetzt anderen Service will, das auch nicht so oft passiert ist man vom reichen Service ein Interface implementiert. Und in diesem Konflikt hat aber kann natürlich häufiger passieren. Und in dem Fall haben wir natürlich noch ein weiteres Tool, womit wir noch etwas genauer an sagen können, welche genaue Bienen wieder rein wollen, dass wir da einmal der Qualifier. Qualifier Location da braucht man einfach nur eine ID hier angeben, die kann irgendwas beliebiges sein. Ich glaube bei die Frau das ist einfach nur der Name der jeweiligen Klasse mit einem Anfang also klein geschrieben, also genau wie es hier habe. Aber ich will das jetzt einfach mal hier nochmal deklarieren. Das heißt, wenn ich in diesem Qualifying-Station wird der die Feier finde jeweiligen Bienen überschrieben. Das ist dann die Idee mit der wir die Bienen aus dem Kontext holen. Und wenn wir das dann zum Beispiel unter unserer Ad-Autobahn sitzen, sagen wir Spring noch mal, dass wir genau diese "Been Here" Kontext bekommen wollen unserer Klasse. Und es hat funktioniert. In diesem Teil des Kurses werden wir uns mit Springboard Data auseinandersetzen und wie wir mit unserer Datenbank Informationen abrufen können und speichern können mit dem Punkt gut. Voraussetzungen sind jetzt, wenn du gerade einschaltet ist nur für diesen Teil des Kurses, dass du dich schon ein bisschen mit Spring gut auskennt. Und vor allem die Themen Wiens und die Pens-Injection finde ich kein Neuland sind. Und du dich mit relationalen Datenbank auskennst und siegte. Also wenn du dich mit den Themen noch gar nicht auskennst, würdest du dich außerhalb des Kurses darüber nochmal informieren. Springboard Data GP ist die Bibliothek mit dem wir uns heute auseinandersetzen. Aber das sind eigentlich drei Bibliotheken oder Themen, die hier gebündelt sind, mit dem wir uns noch mal auseinandersetzen müssen, bevor wir das tun. Weil wir mal CBC steht für Java Database Connectivity. Und ist ein Standard mit dem sich Datenbanken mit Java verbinden können. Und Java kann man mit Jacky SQL Abfragen von der Datenbank abrufen. Das Problem ist allerdings, wenn wir Java programmieren, möchten wir vielleicht nicht zwei Sprachen unserem Coach also, aber SQL und Java. Und dafür habe wurde dann das GPS Standard konzipiert. Das steht für Java Persistence API. Und hat ist entstanden mit dem man definiert hat, wie eigentlich alle Datenkommunikation mit Java verlaufen sollte über Objekte. Da war immer nur das Object-Relational-Mapping, wo man sagt, dass Tabellen in Java-Code einfach nur über Klassen definiert werden können. Das heißt, das sehen wir hier unten. Wir erzeugen hier neue Tabelle. Das würde man vielleicht mit ihnen SQL machen, aber in Java sollen wir dann halt einfach nur eine Klasse definieren. Und die sollte dann automatisch zu einer Tabelle erzeugt werden. Ähnlich auch mit SQL-Abfragen. Mit Jacky wurde halt gesagt, dass man in Java-Code einfach nur eine Methoden-Namen deklarieren sollte. Und dann implizit ein SQL-Query daraus entstehen soll. Das heißt, zum Beispiel hier haben wir einfach nur ein "Find By First nehmen". Und im Hintergrund soll dann die Libri.de diesen Standard implementiert, daraus dann einen Select-Statement machen zum Beispiel. Und Hibernate ist dann die Library in diesem Fall, die das ZDF stand für uns implementiert. Und ist auch eine der häufig benutzten bei Brice dieser Art. Damit man sich das ganze nochmal visualisieren kann: Wir haben unsere Spring-Gut-Anwendungen, die über die GPS-Standard mit dem halben Laib die Datenbank-Informationen abruft und speichert. Das Highlight stellt dann aus unserem zweiten unseren Klassen dann SQL. Und das ganze verbindet sich damit unsere eigentlichen Datenbank über den JB-Driver. Wir werden unsere Datenbank dann durch sogenannte Repository im Java-Code aufrufen. Repository sind einfach nur spezielle Interfaces, die im Hintergrund von uns von Halver nicht automatisch in eine Implementation oder man könnte sagen und Implementation wird automatisch von Hibernate generiert für uns die Datenbank abruft im Hintergrund. Kommt Grund aus bietet uns das Repository so ein bisschen die fundamentalen CRUD-Operation: Create, Read, Update, Delete. Wie durch verschiedene Methoden. Und gibt uns auch Zugriff auf eine Query-Language, die ich so sehr im Java spiele, uns definieren lässt, was für Daten wie von dem Repository brauchen. Und habe nicht übersetzt das ganze dann in SQL. Damit dem Tutorial auch als Vereins folgen können, wenn ihr wollt, wenn ich mich zeigen, wie ich meine Entwicklungsumgebung bzw. eine Datenbank mit Drucker einrichten. Das ist natürlich jetzt kein Ersatz für ein richtiges Dollar-Tutoring, weil ich hier alles einfach überfliegen werde. Und welche nur zeige, wie ich das ganze jetzt hier aufsetze. Das erste, was ihr machen müsst, ist die Location installieren, wenn es noch nicht habt oder Desktop-Version mit einer Gummi aber die Engine mehrfach benutzen. Und das ganze kommt überprüfen, indem hier in erzählte schreibt "Locker bin Strich wünschen". Und da sieht man, dass die Version, die ich benutze, die 20.10.7 ist. Also ist es gleich auf das offizielle Poster es Image. Und werde diesen Pool-Kommando kopieren und hier reinpassen. Und wie sieht, hab ich auch schon Poss als Talker-Image installiert. Das heißt, es gibt man jetzt schneller als bei euch, wenn ihr das zum ersten mal war unheimlich mir zu. Guter letzt noch das Kommando hier unten von "Posco pieren" zum Starten des des Containers beziehungsweise der Datenbank werden noch bin ich nicht bei 5432 fünf vier drei zwei eins meins Ort eingeben. Und das ganze mal laufen lassen. Und jetzt werde ich die Bücher öffnen. Die Biva ist einfach einen Datenbank-Management-Programm, womit man aus einer Datenbank zugreifen kann und da rein gucken kann, was ist da gespeichert. Und Queries ausführen kann mit mySQL zum Beispiel. Und werde jetzt hier auf wieder Post kress angeben war, dass man die Datenbank ist. Das Passwort, was ich hier ein Kommando gesetzt habe, kopieren. Mit Copy die Verbindung testen. Die hat es geklappt. Abschließen. Und schon haben wir unsere Datenbank-Verbindung auf die Viva. Könnten die Daten anschauen, da ist jetzt noch nicht wirklich viel. Und jetzt kommen auch schon den Java-Code wechseln. Hier ist hier wieder ein neues Spring-Gut in den Schleuser-Projekt mit dem Start ab. Ich will jetzt aber zeigen, wie wir hier das ganze mit unserer Datenbank verbinden können, indem wir ein paar Dependencies hinzufügen. Das heißt, ich gehe ja mal auf Maven-Repository, wo man die Pens hieß so hier einfach kopieren kann. Da würde ich mir erst mal den Spring-Booster DPA der Haupt Spring dann unsere Reporter Tories werden es vielleicht mal angucken hier hinzufügen, die dann auch aber nicht implementiert werden. Und wir können uns hier den PostgreSQL die Treffer für unsere Datenbank-Verbindung einfügen. Wenn ihr jetzt eine andere Datenbank sollte ich einen anderen GDP sieht aber natürlich holen. Damit das ganze jetzt auch richtig konfiguriert ist, also Spring weiß man sich damit verbinden soll, werden wir jetzt ja einmal folgende Konfiguration reinsten. Wirklich einmal Diktate Source Plattform an und dem Fall Post Crest, das ist ja unsere Datenbank. Dann muss ich hier wieder mal die NWD-Driver angeben, damit Spring weiß, wie man sich hier verbindet. Dann die die Adresse von Soldaten-Bank also Logo-Host Port 5432 und ist lächelt Orie hast einfach der Name unserer Datenbank. Hier in die Wiese habe ich mir eine Datenbank angelegt, die heißt das gleiche tun. Darauf muss man hier einfach auf Rechtsklick gehen und dann Create und Database. Wir haben hier den Default-Postgres. Username ist einfach Postpress. Passwort habe ich hier beim Einrichten von Docker. Falls euch erinnert auch MySpace wird als das Passwort für die Datenbank eingeben. Und hier habe ich noch ein Setting, das GBL-Auto das Update, was hier steht, heißt normalerweise das Spring beim Starten der Applikation jetzt nichts, keine Veränderungen zum Thema was. Zum Beispiel ich werde das ganze einmal zu ändern zu Create-Drop. Das heißt, dass beim Starten der Applikation einmal die das ganze Tabellen-Scanner für uns erzeugt. Und dann wenn wir die Applikation wieder stoppen wie der Drops also wieder löscht. Da möchte jetzt einmal anfangen und das Klima zu erzeugen. Ich mache einfach nur eine Tabelle. Und zwar die Tabelle unserem Datenbank-Modell hier fehlt. Jetzt muss das an sie hat einmal alle Tieren mit Eternity. Jetzt weiß aber nicht, was ist daraus ein paar Bilder erzeugen soll. Wir können noch definieren, wie diese Tabelle heißt mit dem Ätna-Station. Jetzt wollen wir unseren Cities auch noch ein Index ihm also dass Kanzler-Schüssel geben. Und dafür welches aber das Education benutzen. Und das Generating Value einen zwischen hinzufügen, damit wir nicht jedes mal die neu definieren müssen. Und was zu speichern neben fertig die Strategy generated auto benutzen. Was heißt das, Mieter aber nicht jedes mal die Idee instrumentieren wird möchte ein neues Objekt in die Tabelle rein tun. Das ganze werde ich dann einen blauen machen. Das ganze dienen dann gebe ich meine City-Modell hier noch zwei Attribute aber den Namen und noch ein Bully. Und Alt-Shift einfügen werde ich hier einmal Getter und Setter generieren. Jetzt wechselt zum Repository über, damit wir dann unsere Datenbank abrufen werden. Die muss dann Extension Existenten von dem Springkraut-Repository. Und das ganze wird dann einmal erstes angehen. Das ist für die Repositories für die City-Tabelle ist also von Cities abruft. Und dass sie zum Schlüssel an Long benutzen. Das ganze mit Repository an notieren. Damit Spring uns dafür daraus eine Bienen-Zeug, die wir dann in unseren Kontext rein tun können oder auto wahlen können. Das müsste jetzt auch mal alles testen. Ich werde jetzt einmal das Repositories und im Kontext nehmen und zwei Städte hier unsere Datenbank speichern. Jetzt möchte das Kanzleramt